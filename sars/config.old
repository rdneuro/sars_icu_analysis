# -*- coding: utf-8 -*-
"""
sars.config
===========

Centralized configuration for the SARS-CoV-2 neuroimaging analysis library.

Defines project paths, acquisition parameters, atlas specifications, and
analysis defaults used across all submodules. The configuration automatically
searches for the ``rsfmri_config.json`` file in common locations and falls
back to sensible defaults when the file is not found.

All path attributes are ``pathlib.Path`` objects; downstream modules may
rely on them for I/O operations without extra string-to-path conversions.

Usage
-----
    from sars import config

    print(config.TR)
    print(config.ATLASES["schaefer_100"]["n_rois"])
    print(config.ALL_SUBJECT_IDS)
"""

import json
import warnings
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


# =============================================================================
# JSON CONFIGURATION LOADER
# =============================================================================

_CONFIG_SEARCH_PATHS = [
    Path("/media/rdx/disk4/analysis/covid/proc/sars_cov_2/rsfmri_config.json"),
    Path("/media/rd/disk4/analysis/covid/proc/sars_cov_2_project_rsfmri/"
         "rsfmri_config.json"),
    Path("/home/rd/local/res/sars_cov_2_project_rsfmri/rsfmri_config.json"),
    Path("rsfmri_config.json"),  # current working directory fallback
]

_json_cfg: Dict[str, Any] = {}

for _p in _CONFIG_SEARCH_PATHS:
    if _p.exists():
        with open(_p) as _f:
            _json_cfg = json.load(_f)
        break

if not _json_cfg:
    warnings.warn(
        "rsfmri_config.json not found in any standard location.  "
        "Using built-in defaults.  Set environment variable "
        "SARS_CONFIG=/path/to/rsfmri_config.json or create the file "
        "in the working directory.",
        UserWarning,
    )


# =============================================================================
# PATH AUTO-DETECTION (cross-environment: workstation / laptop / external)
# =============================================================================

def _detect_project_root() -> Path:
    """
    Auto-detect the SARS-CoV-2 project root across environments.

    Search order:
    1. Workstation (nvme)
    2. Laptop (home/rd)
    3. External drive
    4. Fallback to cwd
    """
    candidates = [
        Path("/mnt/nvme1n1p1/sars_cov_2_project"),
        Path("/home/rd/local/res/sars_cov_2_project"),
        Path("/media/rd/disk4/analysis/covid/proc/sars_cov_2"),
        Path("/media/rdx/disk4/analysis/covid/proc/sars_cov_2"),
    ]
    for p in candidates:
        if p.exists():
            return p
    return Path.cwd()


def _detect_rsfmri_root() -> Path:
    """Auto-detect the rs-fMRI project root."""
    candidates = [
        Path("/mnt/nvme1n1p1/sars_cov_2_project"),           # same root on workstation
        Path("/home/rd/local/res/sars_cov_2_project_rsfmri"),
        Path("/media/rd/disk4/analysis/covid/proc/sars_cov_2_project_rsfmri"),
    ]
    for p in candidates:
        if p.exists():
            return p
    return _detect_project_root()


# =============================================================================
# PROJECT PATHS
# =============================================================================

PROJECT_ROOT: Path = Path(
    _json_cfg.get("project_root",
                   "/mnt/nvme1n1p1/sars_cov_2_project")
)

BIDS_DIR: Path = Path(
    _json_cfg.get("bids_dir", PROJECT_ROOT / "data" / "input" / "bids")
)

OUTPUTS_DIR: Path = Path(
    _json_cfg.get("outputs_dir",
                   PROJECT_ROOT / "data" / "output" / "rsfmri")
)

# Derivatives from fMRIPrep
DERIVATIVES_DIR: Path = Path(
    _json_cfg.get("preproc_dir", OUTPUTS_DIR / "fmriprep")
)

# rs-fMRI pipeline outputs (denoising, connectivity, etc.)
RSFMRI_OUT: Path = OUTPUTS_DIR

DENOISE_DIR: Path = Path(
    _json_cfg.get("denoise_dir", OUTPUTS_DIR / "denoising")
)

CONNECTIVITY_DIR: Path = Path(
    _json_cfg.get("connectivity_dir", OUTPUTS_DIR / "connectivity")
)

METRICS_DIR: Path = Path(
    _json_cfg.get("metrics_dir", OUTPUTS_DIR / "regional_metrics")
)

FIGURES_DIR: Path = Path(
    _json_cfg.get("figures_dir", OUTPUTS_DIR / "figures")
)

ATLAS_DIR: Path = PROJECT_ROOT / "info" / "atlases"


# =============================================================================
# ACQUISITION PARAMETERS
# =============================================================================

TR: float = float(_json_cfg.get("tr", 2.217))
"""Repetition time in seconds."""

BANDPASS: tuple = (0.01, 0.08)
"""(high_pass, low_pass) filter cutoffs in Hz."""

SMOOTHING_FWHM: float = 6.0
"""Spatial smoothing kernel FWHM in mm."""

FD_THRESHOLD: float = 0.3
"""Framewise displacement threshold in mm for censoring."""

TRIM_VOLUMES: int = 5
"""Number of initial volumes discarded for T1 equilibration."""


# =============================================================================
# DENOISING
# =============================================================================

DENOISING_STRATEGY: str = "acompcor"
"""Default confound regression strategy (acompcor | simple | scrubbing)."""


# =============================================================================
# SUBJECTS
# =============================================================================

ALL_SUBJECT_IDS: List[str] = _json_cfg.get(
    "subjects",
    [f"sub-{i:02d}" for i in range(1, 25) if i != 21],
)
"""List of all subject IDs available for analysis."""


# =============================================================================
# ATLAS DEFINITIONS
# =============================================================================

# Mapping of atlas keys → metadata used throughout the library.
# Each entry specifies the NIfTI parcellation path, label file path,
# label file parsing details, number of ROIs, and a human-readable name.

ATLASES: Dict[str, Dict[str, Any]] = {
    "synthseg": {
        "name": "SynthSeg",
        "n_rois": 86,
        "nifti": ATLAS_DIR / "synthseg_parc_MNI_2mm.nii.gz",
        "labels_file": ATLAS_DIR / "synthseg_mni_labels.tsv",
        "labels_sep": "\t",
        "label_col": "name",
    },
    "schaefer_100": {
        "name": "Schaefer 100 (7 Networks)",
        "n_rois": 100,
        "nifti": ATLAS_DIR / "Schaefer2018_100Parcels_7Networks_order_FSLMNI152_2mm.nii.gz",
        "labels_file": ATLAS_DIR / "labels_schaefer_100_7networks.csv",
        "labels_sep": ",",
        "label_col": "label_roi",
    },
    "aal3": {
        "name": "AAL3",
        "n_rois": 170,
        "nifti": ATLAS_DIR / "AAL3v1_1mm.nii.gz",
        "labels_file": ATLAS_DIR / "labels_aal3.csv",
        "labels_sep": ",",
        "label_col": "label_roi",
    },
    "brainnetome": {
        "name": "Brainnetome 246",
        "n_rois": 246,
        "nifti": ATLAS_DIR / "BN_Atlas_246_2mm.nii.gz",
        "labels_file": ATLAS_DIR / "labels_brainnetome.csv",
        "labels_sep": ",",
        "label_col": "label_roi",
    },
}
"""Atlas specifications keyed by short name."""


# =============================================================================
# SCHAEFER NETWORK MAPPING
# =============================================================================

SCHAEFER_NETWORK_PREFIXES: Dict[str, str] = {
    "Vis": "Visual",
    "SomMot": "Somatomotor",
    "DorsAttn": "Dorsal Attention",
    "SalVentAttn": "Salience / Ventral Attention",
    "Limbic": "Limbic",
    "Cont": "Frontoparietal Control",
    "Default": "Default Mode",
}
"""Short → full names for Yeo 7-network assignment in Schaefer parcels."""

NETWORK_COLORS: Dict[str, str] = {
    "Vis": "#781286",
    "Visual": "#781286",
    "SomMot": "#4682B4",
    "Somatomotor": "#4682B4",
    "DorsAttn": "#00760E",
    "Dorsal Attention": "#00760E",
    "SalVentAttn": "#C43AFA",
    "Salience / Ventral Attention": "#C43AFA",
    "Limbic": "#DCF8A4",
    "Cont": "#E69422",
    "Frontoparietal Control": "#E69422",
    "Default": "#CD3E4E",
    "Default Mode": "#CD3E4E",
}
"""Canonical Yeo 7-network colors (short and full name keys)."""


# =============================================================================
# ANALYSIS DEFAULTS
# =============================================================================

# Graph analysis
GRAPH_DENSITY: float = 0.15
"""Default proportional threshold for graph construction."""

GRAPH_THRESHOLDS: List[float] = [0.05, 0.10, 0.15, 0.20, 0.25, 0.30]
"""Density range for multi-threshold AUC analysis."""

# Criticality
AVALANCHE_THRESHOLD_SD: float = 1.0
"""Default z-score threshold for avalanche detection (fMRI)."""

DFA_SCALES: Optional[Any] = None
"""Custom DFA scale range; None → auto (4 to T/4)."""

DFA_ORDER: int = 1
"""DFA polynomial detrending order (1 = linear, 2 = quadratic)."""

SAMPEN_M: int = 2
"""Sample Entropy embedding dimension."""

SAMPEN_R: float = 0.2
"""Sample Entropy tolerance (fraction of SD)."""

PERMEN_ORDER: int = 3
"""Permutation Entropy order."""

POWERLAW_XMIN_METHOD: str = "clauset"
"""Power-law x_min estimation method."""

POWERLAW_BOOTSTRAP_N: int = 1000
"""Number of bootstrap iterations for power-law GOF test."""

# Surrogates
N_SURROGATES: int = 99
"""Default number of surrogates for null distributions."""

RANDOM_SEED: int = 42
"""Global random seed for reproducibility."""


# =============================================================================
# CONVENIENCE
# =============================================================================

def get_connectivity_path(
    subject_id: str,
    atlas: str,
    kind: str = "correlation",
    strategy: str = None,
) -> Path:
    """Return the expected .npy path for a connectivity matrix."""
    strategy = strategy or DENOISING_STRATEGY
    return (
    CONNECTIVITY_DIR / atlas / strategy
    / subject_id / f"connectivity_{kind}.npy"
    )


def get_timeseries_path(
    subject_id: str,
    atlas: str,
    strategy: str = None,
) -> Path:
    """Return the expected .npy path for extracted timeseries."""
    strategy = strategy or DENOISING_STRATEGY
    return (
        CONNECTIVITY_DIR / atlas / strategy
        / subject_id / "timeseries.npy"
    )


def get_sc_path(
    subject_id: str,
    atlas: str,
    weight: str = "sift2",
) -> Path:
    """Return the expected .npy path for structural connectivity."""
    sc_base = PROJECT_ROOT / "data" / "output" / "diffusion" / "subjects"

    atlas_dir_map = {
        "schaefer_100": "schaefer100",
        "synthseg_86":  "synthseg",
    }
    atlas_dir = atlas_dir_map.get(atlas, atlas)

    return sc_base / subject_id / "matrices" / atlas_dir / f"connectivity_{weight}.npy"


# =============================================================================
# GNN MULTIMODAL — DATACLASSES
# =============================================================================
# These dataclasses are consumed by the ``gnn_multimodal`` subpackage.
# Keeping them here avoids circular imports and centralises all
# configuration in a single module.
#
# References:
#   Wu & Li (2023). Human Brain Mapping, 44(9), 3885-3896.
#   Baum et al. (2020). NeuroImage, 210, 116612.
#   Vázquez-Rodríguez et al. (2019). PNAS, 116(42), 21219-21227.
#   Chen et al. (2020). SimCLR. ICML 2020.
# =============================================================================

@dataclass
class GATConfig:
    """
    Configuration for Graph Attention Network SC→FC prediction.

    The GAT learns to predict functional connectivity from structural
    connectivity by modelling multi-hop information propagation through
    the structural connectome. Attention weights reveal the most
    critical structural pathways supporting functional communication.

    Mathematical Framework
    ----------------------
    Given structural connectivity matrix S ∈ ℝ^{N×N} and functional
    connectivity matrix F ∈ ℝ^{N×N}, the GAT learns:

        F̂_i = σ(∑_j α_{ij} W h_j)

    where α_{ij} are attention coefficients learned over structural
    edges, W is a learnable weight matrix, and h_j are node features.

    The prediction error ε_i = ||F̂_i - F_i||² at each region reveals
    the degree of SC-FC decoupling.
    """

    # Architecture
    n_heads: int = 4
    hidden_dim: int = 64
    n_layers: int = 3
    dropout: float = 0.3
    residual: bool = True
    layer_norm: bool = True

    # Training
    learning_rate: float = 1e-3
    weight_decay: float = 1e-4
    n_epochs: int = 300
    patience: int = 30
    min_delta: float = 1e-4
    batch_size: int = 1  # per-subject training

    # SC preprocessing
    sc_threshold: float = 0.0        # minimum SC weight to keep
    sc_log_transform: bool = True    # log(1 + SC) transform
    sc_normalize: bool = True        # row-normalise SC

    # FC target
    fc_fisher_z: bool = True         # Fisher-z transform FC
    fc_threshold: float = 0.0        # threshold weak FC

    # Cross-validation
    n_folds: int = 5                 # LOO or k-fold
    n_repetitions: int = 10          # repeated CV

    # Device
    device: str = "cuda"             # "cuda" or "cpu"


@dataclass
class ContrastiveConfig:
    """
    Configuration for multimodal contrastive learning (SC ↔ FC).

    The contrastive framework treats SC and FC from the same subject
    as positive pairs and from different subjects as negative pairs,
    learning aligned representations that capture the coherence
    between structural and functional connectivity.

    Loss Function (NT-Xent)
    -----------------------
    L = -log( exp(sim(z_SC^i, z_FC^i)/τ) / ∑_j exp(sim(z_SC^i, z_FC^j)/τ) )

    where sim(·,·) is cosine similarity and τ is the temperature parameter.

    The learned embeddings reveal:
    1. Regional multimodal coherence (per-node alignment)
    2. Subject-level fingerprints (per-graph embedding)
    3. Subgroup structure (clustering in latent space)
    """

    # Encoder architecture
    encoder_type: str = "GAT"          # "GAT", "GIN", or "GCN"
    hidden_dim: int = 128
    embedding_dim: int = 64
    projection_dim: int = 32
    n_layers: int = 3
    n_heads: int = 4                   # for GAT only
    dropout: float = 0.2

    # Contrastive loss
    temperature: float = 0.1           # NT-Xent temperature τ
    use_hard_negatives: bool = True    # mine hard negatives
    symmetric_loss: bool = True        # bidirectional NT-Xent

    # Training
    learning_rate: float = 5e-4
    weight_decay: float = 1e-4
    n_epochs: int = 500
    patience: int = 50
    warmup_epochs: int = 10
    batch_size: int = 23               # all subjects (full batch)

    # Augmentation (graph augmentation for robustness)
    augment_edge_drop: float = 0.1     # probability of dropping edges
    augment_feat_mask: float = 0.1     # probability of masking features
    use_augmentation: bool = True

    # Analysis
    n_permutations: int = 1000         # for statistical testing
    cluster_method: str = "spectral"   # "spectral", "kmeans", "hdbscan"
    n_clusters_range: Tuple[int, int] = (2, 5)  # range to test

    # Device
    device: str = "cuda"


@dataclass
class GNNMultimodalConfig:
    """
    Master configuration for the combined GNN multimodal analysis pipeline.

    Paths are auto-detected at instantiation time.  To override, pass
    explicit ``project_root``, ``rsfmri_root`` or ``output_dir`` values.

    Directories are **not** created automatically.  Call
    :meth:`prepare_output_dirs` before running the pipeline.
    """

    # Project paths — auto-detected from common locations
    project_root: Path = field(default_factory=lambda: _detect_project_root())
    rsfmri_root: Path = field(default_factory=lambda: _detect_rsfmri_root())
    output_dir: Path = field(
        default_factory=lambda: _detect_project_root() / "data" / "output" / "gnn_multimodal"
    )

    # Atlas selection
    atlases: List[str] = field(
        default_factory=lambda: ["schaefer_100", "aal3", "brainnetome"]
    )

    # Sub-configs
    gat: GATConfig = field(default_factory=GATConfig)
    contrastive: ContrastiveConfig = field(default_factory=ContrastiveConfig)

    # Subjects (re-use the library-wide list)
    subjects: List[str] = field(default_factory=lambda: ALL_SUBJECT_IDS.copy())

    # SC metrics to use as edge weights
    sc_metrics: List[str] = field(
        default_factory=lambda: ["sift2_count", "mean_fa"]
    )

    # FC method
    fc_method: str = "pearson"  # or "partial", "tangent"

    # Reproducibility
    random_seed: int = 42

    # Logging
    verbose: bool = True
    save_checkpoints: bool = True

    def __post_init__(self):
        """Validate paths exist but do NOT auto-create directories."""
        pass

    def prepare_output_dirs(self):
        """
        Create output directories.  Call this explicitly before running
        the pipeline, NOT at config instantiation.
        """
        self.output_dir.mkdir(parents=True, exist_ok=True)
        (self.output_dir / "gat_sc_fc").mkdir(exist_ok=True)
        (self.output_dir / "contrastive").mkdir(exist_ok=True)
        (self.output_dir / "figures").mkdir(exist_ok=True)
        (self.output_dir / "checkpoints").mkdir(exist_ok=True)

    @property
    def sc_dir(self) -> Path:
        """Structural connectivity matrices directory (per-subject)."""
        for subdir in ["output", "outputs"]:
            p = self.project_root / "data" / subdir
            if p.exists():
                return p
        return self.project_root / "data" / "output"

    @property
    def fc_dir(self) -> Path:
        """Functional connectivity matrices directory."""
        for subdir in ["output", "outputs"]:
            p = self.rsfmri_root / "data" / subdir / "rsfmri" / "connectivity"
            if p.exists():
                return p
        return self.rsfmri_root / "data" / "output" / "rsfmri" / "connectivity"

    def validate(self) -> List[str]:
        """Validate configuration."""
        issues = []
        for atlas in self.atlases:
            if atlas not in ATLASES:
                issues.append(f"Unknown atlas: {atlas}")
        if not self.sc_dir.exists():
            issues.append(f"SC directory not found: {self.sc_dir}")
        if not self.fc_dir.exists():
            issues.append(f"FC directory not found: {self.fc_dir}")
        return issues
